/*********************************************************************
*                                                                    *
*                SEGGER Microcontroller GmbH & Co. KG                *
*        Solutions for real time microcontroller applications        *
*                                                                    *
**********************************************************************
*                                                                    *
* C-file generated by:                                               *
*                                                                    *
*        GUI_Builder for emWin version 5.32                          *
*        Compiled Oct  8 2015, 11:59:02                              *
*        (c) 2015 Segger Microcontroller GmbH & Co. KG               *
*                                                                    *
**********************************************************************
*                                                                    *
*        Internet: www.segger.com  Support: support@segger.com       *
*                                                                    *
**********************************************************************
*/

// USER START (Optionally insert additional includes)
// USER END

#include "MENUDLG.h"

#include "GUI.h"

/*********************************************************************
*
*       Defines
*
**********************************************************************
*/
#define ID_WINDOW_0 	(GUI_ID_USER + 0x00)
#define ID_BUTTON_0 	(GUI_ID_USER + 0x10)
#define ID_BUTTON_1 	(GUI_ID_USER + 0x20)
#define ID_BUTTON_2 	(GUI_ID_USER + 0x30)
#define ID_BUTTON_3 	(GUI_ID_USER + 0x40)
#define ID_BUTTON_4 	(GUI_ID_USER + 0x50)
#define ID_BUTTON_5 	(GUI_ID_USER + 0x60)
#define ID_BUTTON_6		(GUI_ID_USER + 0x70)
#define ID_BUTTON_7		(GUI_ID_USER + 0x80)
#define ID_BUTTON_8		(GUI_ID_USER + 0x90)
#define ID_BUTTON_9		(GUI_ID_USER + 0xA0)
#define ID_BUTTON_10	(GUI_ID_USER + 0xB0)
#define ID_BUTTON_11	(GUI_ID_USER + 0xC0)
#define ID_IMAGE_0  	(GUI_ID_USER + 0x0D)
#define ID_SCROLLBAR_0 	(GUI_ID_USER + 0x0E)

#define ID_IMAGE_0_IMAGE_0     0x00

#define LED_BTN 	ID_BUTTON_0
#define TEMP_BTN 	ID_BUTTON_1
#define LIGHT_BTN 	ID_BUTTON_2
#define ACCEL_BTN 	ID_BUTTON_3
#define TIME_BTN 	ID_BUTTON_4
#define TOUCH_BTN 	ID_BUTTON_5
#define SLIDE_BTN 	ID_BUTTON_6
#define BUZZER_BTN 	ID_BUTTON_7
#define MP3_BTN 	ID_BUTTON_8
#define USB_BTN 	ID_BUTTON_9
#define FILES_BTN 	ID_BUTTON_10
#define INFO_BTN 	ID_BUTTON_11

extern GUI_CONST_STORAGE GUI_BITMAP bmled;
extern GUI_CONST_STORAGE GUI_BITMAP bmlight;
extern GUI_CONST_STORAGE GUI_BITMAP bmtemp;
extern GUI_CONST_STORAGE GUI_BITMAP bmtime;
extern GUI_CONST_STORAGE GUI_BITMAP bmtouch;
extern GUI_CONST_STORAGE GUI_BITMAP bmaccel;
extern GUI_CONST_STORAGE GUI_BITMAP bmwallpaper;
extern GUI_CONST_STORAGE GUI_BITMAP bmslideshow;
extern GUI_CONST_STORAGE GUI_BITMAP bmmp3;
extern GUI_CONST_STORAGE GUI_BITMAP bmbuzzer;
extern GUI_CONST_STORAGE GUI_BITMAP bmusb;
extern GUI_CONST_STORAGE GUI_BITMAP bmfiles;
extern GUI_CONST_STORAGE GUI_BITMAP bminfo;

// USER START (Optionally insert additional defines)
// USER END

/*********************************************************************
*
*       Static data
*
**********************************************************************
*/

/*********************************************************************
*
*       _aDialogCreate
*/


static const GUI_WIDGET_CREATE_INFO _aDialogCreate[] = {
  { WINDOW_CreateIndirect, "MENU", ID_WINDOW_0, 0, 0, 480, 272, 0, 0x0, 0 },
  { IMAGE_CreateIndirect, "Image", ID_IMAGE_0, 0, 0, 480, 272, 0, 0, 0 },

  { BUTTON_CreateIndirect, "LED Control", ID_BUTTON_0, 5, 11, 140, 120, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "Temperature", ID_BUTTON_1, 150, 11, 140, 120, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "Light sensor", ID_BUTTON_2, 295, 11, 140, 120, 0, 0x0, 0 },

  { BUTTON_CreateIndirect, "Accelerometer", ID_BUTTON_3, 5, 142, 140, 120, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "Calendar", ID_BUTTON_4, 150, 142, 140, 120, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "Touch panel", ID_BUTTON_5, 295, 142, 140, 120, 0, 0x0, 0 },

  { BUTTON_CreateIndirect, "Slide show", ID_BUTTON_6, 5, 273, 140, 120, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "Buzzer", ID_BUTTON_7, 150, 273, 140, 120, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "MP3", ID_BUTTON_8, 295, 273, 140, 120, 0, 0x0, 0 },

  { BUTTON_CreateIndirect, "USB", ID_BUTTON_9, 5, 404, 140, 120, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "Files", ID_BUTTON_10, 150, 404, 140, 120, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "Info", ID_BUTTON_11, 295, 404, 140, 120, 0, 0x0, 0 },

  { SCROLLBAR_CreateIndirect, "Scrollbar", ID_SCROLLBAR_0, 445, 10, 30, 250, 10, 0x0, 0 },

  // USER START (Optionally insert additional widgets)
  // USER END
};

#define  NUM_OF_BUTTONS 12


/*********************************************************************
*
*       Static code
*
**********************************************************************
*/

// USER START (Optionally insert additional static code)
// USER END

/*********************************************************************
*
*       _cbDialog
*/
static void _cb_Button(WM_MESSAGE * pMsg) {
	switch (pMsg->MsgId) {
	case WM_PAINT:
		GUI_SetAlpha(50);   // Set alpha value for drawing operations
		break;

	}
   BUTTON_Callback(pMsg);
   GUI_SetAlpha(0);
}
static void _cb_Scroll(WM_MESSAGE * pMsg) {
	switch (pMsg->MsgId) {
	case WM_PAINT:
		GUI_SetAlpha(50);   // Set alpha value for drawing operations
		break;

	}
   SCROLLBAR_Callback(pMsg);
   GUI_SetAlpha(0);
}


static void _cbDialog(WM_MESSAGE * pMsg) {
  WM_HWIN hItem;
  int     NCode;
  int     Id;
  int     i;
  int     ScrollValue;
  int     xPos;
  int     yPos;
  // USER START (Optionally insert additional variables)
  // USER END


  switch (pMsg->MsgId) {
  case WM_INIT_DIALOG:
    //
    // Initialization of 'MENU'
    //
	    hItem = pMsg->hWin;
	    WINDOW_SetBkColor(hItem, GUI_MAKE_COLOR(GUI_GREEN)); //0x00FFC751


	    hItem = WM_GetDialogItem(pMsg->hWin, ID_SCROLLBAR_0);
	    SCROLLBAR_SetNumItems(hItem, 13);
	    WM_SetHasTrans(hItem);
	    WM_SetCallback(hItem, _cb_Scroll);
	    SCROLLBAR_SetSkinClassic(hItem);
	    WIDGET_SetEffect(hItem, &WIDGET_Effect_None);
	    SCROLLBAR_SetColor(hItem, SCROLLBAR_CI_ARROW, GUI_ORANGE);
	    SCROLLBAR_SetColor(hItem, SCROLLBAR_CI_SHAFT, GUI_LIGHTGRAY);
	    SCROLLBAR_SetColor(hItem, SCROLLBAR_CI_THUMB, GUI_DARKGRAY);

	    hItem = WM_GetDialogItem(pMsg->hWin, ID_IMAGE_0);
	    IMAGE_SetBitmap(hItem, &bmwallpaper);

	    for(i=0; i<NUM_OF_BUTTONS; i++)
	    {
		    hItem = WM_GetDialogItem(pMsg->hWin, _aDialogCreate[i + 2].Id);
		    WM_SetHasTrans(hItem);
		    WM_SetCallback(hItem, _cb_Button);
		    BUTTON_SetSkinClassic(hItem);
		    WIDGET_SetEffect(hItem, &WIDGET_Effect_None);
		    BUTTON_SetBkColor(hItem, BUTTON_CI_UNPRESSED, GUI_DARKGRAY);
		    BUTTON_SetBkColor(hItem, BUTTON_CI_PRESSED, GUI_BROWN);
		    BUTTON_SetTextColor(hItem, BUTTON_CI_UNPRESSED, GUI_ORANGE);
		    BUTTON_SetTextColor(hItem, BUTTON_CI_PRESSED, GUI_LIGHTGRAY);
		    BUTTON_SetFrameColor(hItem, GUI_ORANGE);
		    BUTTON_SetFont(hItem, GUI_FONT_20B_1);

		    BUTTON_SetFocussable(hItem, 0);
		    switch(i)
		    {
				case 0:
				    BUTTON_SetBitmapEx(hItem, BUTTON_CI_UNPRESSED,&bmled, 20, 10);
					break;
				case 1:
				    BUTTON_SetBitmapEx(hItem, BUTTON_CI_UNPRESSED,&bmtemp, 20, 10);
					break;
				case 2:
				    BUTTON_SetBitmapEx(hItem, BUTTON_CI_UNPRESSED,&bmlight, 20, 10);
					break;
				case 3:
				    BUTTON_SetBitmapEx(hItem, BUTTON_CI_UNPRESSED,&bmaccel, 20, 10);
					break;
				case 4:
				    BUTTON_SetBitmapEx(hItem, BUTTON_CI_UNPRESSED,&bmtime, 20, 10);
					break;
				case 5:
				    BUTTON_SetBitmapEx(hItem, BUTTON_CI_UNPRESSED,&bmtouch, 20, 10);
					break;
				case 6:
				    BUTTON_SetBitmapEx(hItem, BUTTON_CI_UNPRESSED,&bmslideshow, 20, 10);
					break;
				case 7:
				    BUTTON_SetBitmapEx(hItem, BUTTON_CI_UNPRESSED,&bmbuzzer, 20, 10);
					break;
				case 8:
				    BUTTON_SetBitmapEx(hItem, BUTTON_CI_UNPRESSED,&bmmp3, 20, 10);
					break;
				case 9:
				    BUTTON_SetBitmapEx(hItem, BUTTON_CI_UNPRESSED,&bmusb, 20, 10);
					break;
				case 10:
				    BUTTON_SetBitmapEx(hItem, BUTTON_CI_UNPRESSED,&bmfiles, 20, 10);
					break;
				case 11:
				    BUTTON_SetBitmapEx(hItem, BUTTON_CI_UNPRESSED,&bminfo, 20, 10);
					break;

		    }

		    BUTTON_SetText(hItem, _aDialogCreate[i + 2].pName);
		    BUTTON_SetTextOffset(hItem, 0, 40);
	    }

    // USER START (Optionally insert additional code for further widget initialization)
    // USER END
    break;
  case WM_NOTIFY_PARENT:
    Id    = WM_GetId(pMsg->hWinSrc);
    NCode = pMsg->Data.v;
    switch(Id) {
    case ID_SCROLLBAR_0: // Notifications sent by 'Scrollbar'
          switch(NCode) {
          case WM_NOTIFICATION_CLICKED:
            // USER START (Optionally insert code for reacting on notification message)
            // USER END
            break;
          case WM_NOTIFICATION_RELEASED:
            // USER START (Optionally insert code for reacting on notification message)
            // USER END
            break;
          case WM_NOTIFICATION_VALUE_CHANGED:
              hItem = WM_GetDialogItem(pMsg->hWin, Id);
              ScrollValue =131* SCROLLBAR_GetValue(hItem);
              for (i = 0; i <NUM_OF_BUTTONS; i++)
              {
                hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_0+(i<<4));
                xPos = _aDialogCreate[i + 2].x0;
                yPos = _aDialogCreate[i + 2].y0- ScrollValue;;
                WM_MoveTo(hItem, xPos, yPos);
              }
            // USER START (Optionally insert code for reacting on notification message)
            // USER END
            break;
          // USER START (Optionally insert additional code for further notification handling)
          // USER END
          }
          break;
        // USER START (Optionally insert additional code for further Ids)
        // USER END

    case ID_BUTTON_0: // Notifications sent by 'LED'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case ID_BUTTON_1: // Notifications sent by 'LIGHT'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case ID_BUTTON_2: // Notifications sent by 'TEMP'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    // USER START (Optionally insert additional code for further Ids)
    // USER END
    }
    break;
  // USER START (Optionally insert additional message handling)
  // USER END
  default:
    WM_DefaultProc(pMsg);
    break;
  }
}

/*********************************************************************
*
*       Public code
*
**********************************************************************
*/
/*********************************************************************
*
*       CreateMENU
*/
WM_HWIN CreateMENU(void);
WM_HWIN CreateMENU(void) {
  WM_HWIN hWin;

  hWin = GUI_CreateDialogBox(_aDialogCreate, GUI_COUNTOF(_aDialogCreate), _cbDialog, WM_HBKWIN, 0, 0);
  return hWin;
}

// USER START (Optionally insert additional public code)
// USER END

/*************************** End of file ****************************/
